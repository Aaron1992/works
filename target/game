#!/usr/bin/python3
import socket
import argparse
from time import sleep
import re
import sys

class Player():
    con = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    connected = False
    def __init__(self,ip,port,id):
        self.ip = ip
        self.port = port
        self.id = id
        self.con.bind((ip, port))

    def connect(self,ip,port):
        while True:
            try:
                self.con.connect((ip,port))
                break
            except Exception as e:
                print(e)
                print('connect to %s failed, retrying...'%(ip))
                sleep(1)
        print("connect to server %s:%d success."%(ip,port))
        self.connected = True

    def register(self):
        if not self.connected:
            print("Must connect to a server before registering.")
            return False
        reg_msg = "reg: " + str(self.id) + " " + "test" + "\n"
        print(reg_msg,end='')
        self.con.send(reg_msg.encode())

    def play(self):
        while True:
            try:
                res = self.con.recv(1024)
                if(len(res)>0):
                    msg = res.decode()
                    self.process_msg(msg)
            except SystemExit:
                self.con.close()
                break
            finally:
                pass

    def process_msg(self,msg):
        processors = {'seat':SeatProcessor,
                'blind':BlindProcessor,
                'hold':HoldProcessor,
                'inquire':InquireProcessor,
                'flop':FlopProcessor,
                'turn':TurnProcessor,
                'river':RiverProcessor,
                'showdown':ShowdownProcessor,
                'pot-win':PotWinProcessor}

        msg = msg.strip()
        print(msg)
        print("===the next msg===")
        if "game-over" in msg:
            sys.exit()
        msg_re = re.compile("(?P<type>[\w\-]+)\/(?P<info>[\s\S]+)\/(?P=type)")
        match = msg_re.search(msg)
        if match:
            info_type = match.group("type").strip()
            info_content = match.group("info").strip()
        else:
            print("un recognized message: \n%s"%(msg))
            return False
        if info_type in processors:
            processor = processors[info_type]()
        else:
            print("no processor for info type: %s"%(info_type))
            return False
        response = processor.process(info_content)
        if response:
            self.con.send(response.encode())
            print("send: %s"%(response))
        pass


class Processor():
    def process(self,content):
        print(content)
    pass

class SeatProcessor(Processor):
    pass

class GameOverProcessor(Processor):
    pass

class BlindProcessor(Processor):
    pass

class HoldProcessor(Processor):
    pass

class InquireProcessor(Processor):
    def process(self, content):
        return "all_in \n"
    pass

class FlopProcessor(Processor):
    pass

class TurnProcessor(Processor):
    pass

class RiverProcessor(Processor):
    pass

class ShowdownProcessor(Processor):
    pass

class PotWinProcessor(Processor):
    pass

class GameOverProcessor(Processor):
    pass

def main():
    parser = argparse.ArgumentParser(description='The game player.')
    parser.add_argument('server_ip',)
    parser.add_argument('server_port',type=int)
    parser.add_argument('player_ip')
    parser.add_argument('player_port',type=int)
    parser.add_argument('id',type=int)

    args = parser.parse_args()
    print(args)
    server ={'ip':args.server_ip,
            'port':args.server_port
            }

    player = Player(args.player_ip, args.player_port, args.id)
    player.connect(**server)
    player.register()
    player.play()

if __name__ == "__main__":
    main()




